package ru.geekbrains.java3.lesson6_logging_testing.logging;

import java.io.IOException;
import java.util.logging.*;

public class MainClass1 {

    // Логирование предоставляет возможность вести журнал, в котором будут фиксироваться действия пользователя,
    // события, возникающие ошибки и возможные причины их появления. Журнал можно хранить в отдельном файле.
    // Логирование будет производить через стандартный логер Java (java util logging)
    // В каждом классе, в котором нужно записывать логи создается конструкция

    // У каждого логера должно быть имя и как правило оно должно совпадать
    // с именем класса или именем пакета, в котором этот класс находится. Чтобы создать логер нужно запросить его и
    // указать в кобках его имя. В данном примере получаем имя класса и передаем его в качестве названия логера
//    private static final Logger logger = Logger.getLogger(MainClass1.class.getName());

    // а здесь получаем логер по умолчанию, самый верхний в иерархии.
    // Т.е. после того как мы запросили логер, он создается с указанными именем и встраивается в цепочку логеров
    private static final Logger logger = Logger.getLogger("");

    public static void main(String[] args) {
        // На входе логера стоит фильтр, который принимает входящее сообщение и фильтрует по времени, тексту и т.д.,
        // затем оно попадает в логер, а из логера в handler. Handler так же имеет свой фильтр и
        // форматор (Filter и Formator). После handler сообщение попадает в систему. У хэндлера и логера
        // есть некий уровень. Фильтры позволяют отфильтровать большой объем информации, который может поступать
        // в наш логер

        // Сам логер является неким хабом, который может раскидывать одно сообщение по целой куче блоков(хэндлеров).
        // К одному логеру может быть подключено от 0 до бесконечного количества хэндлеров.

        // Level в logger и handler
        // Сообщения несут информацию, которая может быть полезной или не очень.
        // Они могут подразделяться на уровни (по убыванию важности сообщений):
        // OFF - нежелательно
        // SEVER - верхний уровень опасности, чего совсем не должно случиться, очень важное сообщение
        // WARNING - что-то пошло не так, но система еще может жить, стоит обратить на это внимание
        // INFO - сообщение о том, что система запустилась и тд
        // CONFIG - сообщения с параметрами
        // FINE - просто информация
        // FINER - незначительная информация
        // FINEST - совсем неважная информация
        // ALL - нежелательно

        // Эти уровни задают логеру нижнюю границу принимаемых сообщений.
        // Если создать логер на уровне INFO, то он не будет принимать сообщения уровня INFO и выше.
        // Если выставить уровень SEVERE, то никакие сообщения кроме как с этого уровня приниматься не будут
        // Уровень OFF полностью выключает логирование, ALL логирует все действия
        // ПО УМОЛЧАНИЮ В ЛОГЕРЕ УКАЗАН УРОВЕНЬ INFO, т.е. сообщения от уровней ниже не проходят
        logger.setLevel(Level.INFO);
        // handler тоже имеет предустановленное значение уровня, и если уровень переопределить только у логера, то это может не привести к выводу сообщения, если хэндлер на нестроен на обработку сообщений такого уровня
        logger.getHandlers()[0].setLevel(Level.INFO);


//        logger.log(Level.SEVERE, "SEVERE");
//        logger.log(Level.INFO, "INFO");
//        logger.log(Level.FINE, "FINE");
//        logger.log(Level.CONFIG, "CONFIG");
//        logger.log(Level.WARNING, "WARNING");

        // задача handler вывести полученное сообщение во внешнюю систему: консоль, файл, паять или сокет
        // Handler содержит Filter и Formater.
        // Фильтр отвечает за прием сообщения, а форматер за внешний вид,
        // т.к. сообщение содержит много информации: дату, время, откуда пришло, уровень
        // По умолчанию хэндлер в JavaUtilLogger поддерживает два стандартных форматора:
//        logger.getHandlers()[0].setFormatter(new SimpleFormatter());
//        logger.getHandlers()[0].setFormatter(new XMLFormatter());

        // чтобы создать собственный форматор используем следующую конструкцию
        logger.getHandlers()[0].setFormatter(new Formatter() {
            @Override
            public String format(LogRecord record) { // LogRecord содержит всю информацию о логе сообщения
                return record.getLevel() + "\t" + record.getMessage() + "\t......\t" + record.getMillis() + "\n";
            }
        });

        // таким же образом можно настроить фильтр
//        logger.getHandlers()[0].setFilter(new Filter() {
//            @Override
//            public boolean isLoggable(LogRecord record) {
//                return record.getMessage().startsWith("Java");
//            }
//        });

        // По умолчанию к логеру привязан хэндлер, который отправляет логи в консоль
        // Создадим свой хэндлер, который будет писать логи в файл и добавим этот хэндлер в уже существующий логер

        Handler myHand = null;
        try {
            myHand = new FileHandler("mylog.log");
        } catch (IOException e) {
            e.printStackTrace();
        }

        myHand.setLevel(Level.FINE);
        myHand.setFormatter(new SimpleFormatter());
        logger.addHandler(myHand);

        logger.log(Level.SEVERE, "SEVERE");
        logger.log(Level.WARNING, "WARNING");
        logger.log(Level.INFO, "INFO");
        logger.log(Level.CONFIG, "CONFIG");
        logger.log(Level.FINE, "FINE");
    }
}
